<seo metak="data analysis,annotation,segmentation,scripts" metad="data analysis,annotation,segmentation,scripts" />
<div style="float:right;">
{{Infobox
| software       = ImageJ/Fiji
| name           = BAR
| maintainer     = {{Person|Tiago}}
| source         = {{GitHub|org=tferr|repo=Scripts}}
| released       = June 2014
| latest version = '''1.1.9 November 2016''' ({{GitHub|org=tferr|repo=Scripts/releases|label=Changelog}})
| category       = [[:Category:Analysis|Analysis]], [[:Category:Image annotation|Annotation]], [[:Category:Filtering|Filtering]], [[:Category:Segmentation|Segmentation]], [[:Category:Scripting|Scripting]]
}}
</div>
{{TOC}}
'''BAR''': A collection of '''B'''roadly '''A'''pplicable '''R'''outines.

The collection contains [[Macros]], [[Scripts]] and [[Plugins]] focused on Data Analysis, Image Annotation and Image Segmentation. It is curated using {{GitHub|org=tferr|repo=Scripts#ij-bar|label=GitHub}} and distributed as an optional [[List_of_update_sites|update site]].

== Installation ==
Run {{bc|Help|Update...}} and choose ''Manage update sites''. Activate the ''BAR'' checkbox in the alphabetically-sorted list of update sites. Press ''OK'', then ''Apply changes''. Restart ImageJ. That's it. Enjoy BAR!

== Description ==
BAR files are accessible through a dedicated top-level menu subdivided in task-oriented categories. All routines should be documented on {{GitHub|org=tferr|repo=Scripts|path=README.md#ij-bar|label= GitHub}}.

Some of the scripts have a dedicated documentation page, others feature built-in help, while a handful were deemed too simple to require dedicated instructions. Nevertheless, all files contain useful commentary at the top of the source code file. '''Remember:''' You can open all the scripts using the [[#OpeningBAR|Shift key]].

=== List of BARs ===
[[ File:BARsnapshot.png|right|Overview of BAR (v1.0.0)]]
;{{GitHub|org=tferr|repo=Scripts|path=README.md#analysis|label= Analysis}}<span id="Analysis"></span>
:{{GitHub|org=tferr|repo=Scripts|path=Analysis/README.md#multichannel-plot-profile|label=Multichannel Plot Profile}}, {{GitHub|org=tferr|repo=Scripts|path=Analysis/README.md#multichannel-zt-axis-profile|label=Multichannel ZT-axis Profile}}, {{GitHub|org=tferr|repo=Scripts|path=Analysis/README.md#smoothed-plot-profile|label=Smoothed Plot Profile}}

;{{GitHub|org=tferr|repo=Scripts|path=README.md#image-annotation|label=Annotation}}<span id="Annotation"></span>
:{{GitHub|org=tferr|repo=Scripts|path=Annotation/README.md#combine-orthogonal-views|label=Combine Orthogonal Views}}, {{GitHub|org=tferr|repo=Scripts|path=Annotation/README.md#cumulative-z-project|label=Cumulative Z Project}}, {{GitHub|org=tferr|repo=Scripts|path=Annotation/README.md#roi-color-coder|label=ROI Color Coder}}

;{{GitHub|org=tferr|repo=Scripts|path=README.md#data-analysis|label=Data Analysis}}<span id="Data_Analysis"></span>
:{{GitHub|org=tferr|repo=Scripts|path=Data_Analysis/README.md#create-boxplot|label=Create Boxplot}}, {{GitHub|org=tferr|repo=Scripts|path=Data_Analysis/README.md#distribution-plotter|label=Distribution Plotter}}, [[Find Peaks]], [[Sholl_Analysis#Complementary_Tools|Fit Polynomial]], {{GitHub|org=tferr|repo=Scripts|path=Data_Analysis/README.md#plot-xy-data|label=Plot XY Data}}

;{{GitHub|org=tferr|repo=Scripts|path=README.md#image-segmentation|label=Segmentation}}<span id="Segmentation"></span>
:{{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#shen-castan-edge-detector|label=Shen-Castan Edge Detector}}, {{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#apply-threshold-to-roi|label=Apply Threshold To ROI}}, {{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#clear-thresholded-pixels|label=Clear Thresholded Pixels}}, {{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#remove-isolated-pixels|label=Remove Isolated Pixels}}, {{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#threshold-from-background|label=Threshold From Background}}, {{GitHub|org=tferr|repo=Scripts|path=Segmentation/README.md#wipe-background|label=Wipe Background}}

;{{GitHub|org=tferr|repo=Scripts|path=README.md#snippets|label=Snippets}} and  {{GitHub|org=tferr|repo=Scripts|path=/lib#lib|label=BAR lib}}<span id="SnippetsList"></span>
:Described in [[#Scripting_BARs|Scripting BARs]]

;{{GitHub|org=tferr|repo=Scripts|path=README.md#tools-and-toolsets|label=Tools and Toolsets}}<span id="Tools"></span>
:{{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#calibration-menu|label=Calibration Menu}}, {{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#list-folder-menu|label=List Folder Menu}}, {{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#segment-profile-tool|label=Segment Profile}}, {{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#shortcuts-menu|label=Shortcuts Menu}}, {{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#roi-manager-tools|label=ROI Manager Tools}}, {{GitHub|org=tferr|repo=Scripts|path=Tools/README.md#toolset-creator|label=Toolset Creator}}

;{{GitHub|org=tferr|repo=Scripts|path=README.md#utilities|label=Utilities}}<span id="Utilities"></span>
:[[#Commander|Commander]]

== Accessing BARs ==
As with all ImageJ commands, BAR scripts can be accessed in multiple ways: 1) through the <span style="border-bottom:1px dotted #ccc;">BAR▷ </span> menu, 2) the [[#Context_Menu|Context Menu]], 3) [[#Keyboard_Shortcuts|Keyboard Shortcuts]], 3) the ''Shortcuts Menu Tool'' (<span style="border-bottom:1px dotted #ccc;">BAR▷ Tool Installers▷ Install Shortcuts Menu</span>), that registers frequently used commands in the ImageJ toolbar, 4) by [[#ExpediteAccess|pressing]] {{key press|[[#ExpediteAccess|L]]}}, or 5) from other [[#Scripting_BARs|scripts, macros and plugins]].
{{Tip
| id = OpeningBAR
| tip = You can open any BAR script by holding {{key press|Shift}} while selecting its name from the <span style="border-bottom:1px dotted #ccc;">BAR▷</span> menu. For pre-compiled java plugins, the source code is available through the <span style="border-bottom:1px dotted #ccc;">About BAR...</span> command.
}}
=== Context Menu ===
[[File:TransposableBarMenu.png|350px|thumb|BAR features a neat mechanism that allows <span style="border-bottom:1px dotted #ccc;">BAR▷</span> commands to shuttle between the main menu bar and the image's context menu.]]
<span style="border-bottom:1px dotted #ccc;">BAR▷ </span> submenus can be appended to the image's context menu (the menu that pops up when right-clicking on the image canvas) by running <span style="border-bottom:1px dotted #ccc;">BAR▷ <i>Submenu</i>▷Move Menu (Context<>Main)</span>. The transfer is bidirectional: once in the context menu, running the same command will place the submenu back in the main menu bar.

The shuttling mechanism is not permanent, i.e., it will not be remembered across restarts. However, it is macro recordable which means it can be imposed at startup, using the ImageJ macro language. So, e.g., to install <span style="border-bottom:1px dotted #ccc;">BAR▷ Segmentation▷</span> in the context menu, one would:
# Start the Macro Recorder (<span style="border-bottom:1px dotted #ccc;"> Plugins▷ Macros▷ Record...</span>)
# Run <span style="border-bottom:1px dotted #ccc;">BAR▷ Segmentation▷ Move Menu (Context<>Main)</span>
# Open the <span style="border-bottom:1px dotted #ccc;">Edit▷ Options▷ Startup...</span> window and paste the string generated by the Macro Recorder into its text area so that ImageJ can run the command at every startup.


It may be wise to allow ImageJ enough time to register all scripts before triggering transfers to the context menu. This can be achieved through the built-in macro function <tt>[http://imagej.nih.gov/ij/developer/macro/functions.html#wait wait()]</tt>. For a slow setup requiring at least 1 second (1000 milliseconds), the pasted code would look something like this:

<center>[[Image:StartupBAR.png|center|380px]]</center>


'''Notes'''
* The several <span style="border-bottom:1px dotted #ccc;">Move Menu (Context<>Main)</span> commands across <span style="border-bottom:1px dotted #ccc;"> BAR▷ </span> submenus do not use the same label and are distinguishable by extra trailing spaces. This is intentional because all ImageJ commands must have unique names.
* Any toolset loaded via the ">>" ''More Tools'' drop down menu can define its own contextual menu (as detailed in the [http://imagej.net/docs/guide/146-21.html#sec:ContextualMenu ImageJ User Guide], the contextual menu is controlled by a macro called ''Popup Menu'' that gets loaded at startup). To have BARs immediately available when such toolsets are loaded, just append the same <tt>run("Move Menu (Context<>Main)");</tt> call described above for StartupMacros.

=== Commander ===
[[File:CommanderOverview.png|400px|thumb|Commander overview (BAR 1.1.2).]]
Since the majority of BARs are scripts stored in dedicated files, BAR features Commander ({{bc|BAR|BAR Commander...}}), a keyboard-based file browser that produces filtered lists of directory contents.

It is a productivity tool that applies the principles of [[Using_the_Command_Launcher|Command Launcher]] to file browsing, providing instant access to files just by typing abbreviations of filenames. It serves two purposes: 1) to expedite the opening of files and 2) to produce filtered lists of directory contents. Features include: drag-and-drop support, interaction with native file manager, regex filtering, and a built-in console for common operations.

<i>Console mode</i> is triggered by typing {{key|!}}, which evokes a list of searchable commands so that all file navigation can be done exclusively with the keyboard. Some of these (<tt>cd</tt>, <tt>ls</tt>, <tt>pwd</tt>, etc.) are reminiscent of commands found in most command-line interfaces. Here are some examples:
;To access ImageJ's LUT folder:Type {{key|!|L|U|T|Enter}}
;To access all JavaScript [[#lib|lib files]]:Type {{key|!|L|I|B|Enter}}, then {{key|.|J|S}}
;To reveal the directory of active image:Type {{key|!|I|M|P|Enter}}, then choose {{bc|Reveal Path}}.
;To access Commander's built-in help:Type {{key|!|H|E|L|P|Enter}}
;To extract the paths of all TIFF images in a directory:Drag and drop the desired folder into the Commander list<br>Type {{key|T|I|F|Enter}}<br>Choose {{bc|Print Current List}} in the Options Menu or press {{key|Control|P}} ({{key|Command|P}} in Mac OS).

=== Keyboard Shortcuts ===
You can use <span style="border-bottom:1px dotted #ccc;">Plugins▷ Shortcuts▷ Create Shortcut...</span> to assign hotkeys (e.g., keyboard key that you do not use frequently such as {{key press|0}}  or {{key press|F7}}) to any script registered in the <span style="border-bottom:1px dotted #ccc;">BAR▷</span> menu. These shortcuts will be listed in <span style="border-bottom:1px dotted #ccc;">Plugins▷ Shortcuts▷</span> and are remembered across restarts.

Alternatively, keyboard shortcuts can be defined in macros that call BAR commands by placing the [[Introduction_into_Macro_Programming#Keyboard_shortcuts|shortcut key within square brackets]] at the end of the macro name. Such macros can pass specific options to BAR commands, allowing scripts to run without prompt. Example:
<source lang="java">
macro "Remove Round Structures [0]" {
    run("Wipe Background", "size=100 circ.=0.75-1.00"); // Runs Wipe_Background.ijm with the specified parameters
}
</source>
As [[#Context_Menu|mentioned]], such macros can then be pasted into the text area of <span style="border-bottom:1px dotted #ccc;">Edit▷ Options▷ Startup...</span> so that they can be executed when ImageJ starts up.
{{Tip
| id = ExpediteAccess
| tip = Two other expedite ways of retrieving commands include: 1) Pressing {{key press|L}}, the shortcut for the [[Using_the_Command_Launcher|Command Launcher]] and 2) Pressing {{key press|9}}, the default shortcut for the ''Recent Commands'' list.
}}== Scripting BARs  ==
Although BARs can be used as standalone commands, the scripts and plugins in BAR become more useful when incorporated into other routines.

You can use BARs as a starting point for your own workflows. Whether you are just looking to automate a simple task or you are an advanced developer, you can use BAR to achieve your analysis goals more easily, by means of Snippets - source code templates - and libs - scripting additions to be shared across routines.

=== Snippets ===
[[File:SnippetCreator.png|350px|thumb|{{Bc|BAR|Snippets|NewSnippet...}} (BAR 1.1.0)]]
BAR contains a directory, ''plugins/Scripts/BAR/Snippets/'', containing  multi-language [https://github.com/tferr/Scripts/tree/master/Snippets examples] that you can customize and recycle in your own scripts. You can, of course, also retrieve code and inspiration from the more complete BARs in the remaining ''plugins/Scripts/BAR/'' subdirectories. Any script or macro file stored in the ''Snippets/'', folder with an underscore "_" in the filename will be listed in <span style="border-bottom:1px dotted #ccc;">BAR▷ Snippets▷</span>. The <span style="border-bottom:1px dotted #ccc;">Snippets▷</span> menu contains some utilities to help you manage your scripts:

;List Snippets:Prints a table listing all scripts in ''plugins/Scripts/BAR/Snippets/''. Files can then be opened in the [[Script Editor]] by double-clicking on their filename.
;New Snippet: A java plugin that speeds up the creation of new scripts, pre-configured to use [[#lib|BAR lib]].
;Reveal Snippets:Opens ''plugins/Scripts/BAR/Snippets/'' in the file browser of the operating system.
;Search BAR: Searches the contents of BAR files.
{{Tip
| id = API
| tip = BAR provides several utility methods that simplify the creation of [[#Snippets|Snippets]] and [[#BAR_lib|BAR lib]] usage. These are documented in the [http://tferr.github.io/Scripts/apidocs/ BAR API], that can be accessed using {{bc|BAR|About BAR...}}. {{bc|About BAR...}} also provides links to several online resources including the [http://search.imagej.net ImageJ Search Portal], [http://javadoc.imagej.net ImageJ Javadocs], and the [https://github.com/tferr/Scripts#ij-bar GitHub documentation] of BAR.
}}
<span id="lib"></span>

=== BAR lib ===
{{Scripting}}{{GitHub|org=tferr|repo=Scripts|path=/lib/README.md#lib|label=BAR libs}} (stored in the ''/BAR/lib/'' directory) are centralized libraries ([[BeanShell_Scripting|BeanShell]], [[Introduction_into_Macro_Programming|IJM]] and [[Jython_Scripting|Python]], etc.) that can be shared across files. These libraries serve as scripting additions to [[#Snippets|Snippets]] and other routines.

Do you find yourself copy and pasting functions from one file to the other? Do you keep on writing the same lines of code? Do you have some key code written across different languages? Would you like to make side-by-side comparisons of scripting languages? Then, BAR lib is for you.

The idea is quite simple: Reusable functions and methods are written to a lib file that gets loaded at execution time so that it can be called by the running script. <span style="border-bottom:1px dotted #ccc;">BAR▷ Snippets▷ New Snippet...</span> exemplifies how to use these scripting add-ons. Here is a BeanShell example:
<source lang="java">
// Add BAR/lib to classpath
addClassPath(bar.Utils.getBARDir()); // See http://tferr.github.io/Scripts/apidocs/index.html?bar/Utils.html for details
importCommands("lib/");
// Load BARlib.bsh
BARlib();
// Confirm availability of BARlib
lib = new BARlib();
lib.confirmLoading();
</source>
Run it in the [[Script Editor]] ({{bc|File|New|Script...}}), and you should be greeted by a ''"BAR lib successfully loaded"'' message. Further details are provided on the {{GitHub|org=tferr|repo=Scripts|path=/lib#lib|label=GitHub lib page}} and on the documentation of the [http://tferr.github.io/Scripts/apidocs/index.html?bar/Utils.html bar.Utils] class.

=== Batch Processors ===
Some of the scripts included in ''/BAR/Snippets/'' are scripts that apply a [[How_to_apply_a_common_operation_to_a_complete_directory|common operation to a directory]]. These
[[Batch_Processing|batch processors]] are implemented in different languages and perform the following operations:
# Take an input folder specified by the user
# Apply a series of operations to individual files of matched extension(s)
# Save processed files as TIFF to a dedicated directory, so that no files are overwritten

Typically each of these tasks is handled by separated functions so only the function processing single files needs to be edited. In the {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_PY.py|label=Python}} and {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_IJM.ijm|label=IJM}} implementation, this processing function is called <code>myRoutines()</code>. Note that when editing <code>myRoutines()</code> we do not need to worry about opening, closing or saving the image without overriding the original file, because those tasks are already performed by other functions.
<span id="ProcessingFunction">
==== Processing Functions ====
The file-processing function can include your own code, code generated by the Macro Recorder (<span style="border-bottom:1px dotted #ccc;">Plugins▷ Macros▷ Record...</span>), pre-existing snippets or methods/functions defined in a common [[#lib|BAR lib]] file.

IJM example, running a macro and a python script in the ''Snippets/'' (another [[#IJMlib|example below]] exemplifies how to call a macro function from {{GitHub|org=tferr|repo=Scripts|path=lib/BARlib.ijm|label=BARlib.ijm}}):
<source lang="java">
function myRoutines() {
	snippetsPath = call("bar.Utils.getSnippetsDir");
	runMacro(snippetsPath + "MyCoolestMacro.ijm");
	eval("python", File.openAsString(snippetsPath + "Median_Filter.py"));
}</source>
Jython example, demonstrating how to 1) load [[#lib|BAR lib]] (in this case {{GitHub|org=tferr|repo=Scripts|path=lib/BARlib.py|label=BARlib.py}}, using code generated by <span style="border-bottom:1px dotted #ccc;">Bar▷ Snippets▷ New Snippet...</span>) and 2) how to run a Snippet (in this case {{GitHub|org=tferr|repo=Scripts|path=Snippets/Median_Filter.py|label=Median_Filter.py}}):
<source lang="python">
def myRoutines():
    import sys, ij, bar

    # 1) Call a lib function:
    # 1.1) Extend the search path to /BAR/lib/
    sys.path.append(bar.Utils.getLibDir())
    # 1.2) Import all functions in /BAR/lib/BARlib.py
    import BARlib as lib
    # 1.3) Call a function from the file
    lib.confirmLoading()

    # 2) Run a script directly:
    from org.python.util import PythonInterpreter
    script = bar.Utils.getSnippetsDir() + "Median_Filter.py"
    PythonInterpreter().execfile(script)
</source>
{{Tip
| id = BuiltinProcessor
| tip = Note also that there is an [[Batch_Processing#Easy_option|easier]] (but less flexible) way to [[Batch_Processing|batch process]] a folder: The built-in <span style="border-bottom:1px dotted #ccc;">Process▷ Batch▷ Macro...</span> [[Batch_Processing#Easy_option|command]].

In this case, you only need to paste the contents of your <code>myRoutines()</code> function into the text area of the command. However, by default, <span style="border-bottom:1px dotted #ccc;">Process▷ Batch▷ Macro...</span> assumes you want to process ''all'' the files in a directory. If that is not the case, i.e., you want to restrict the processing to certain file types, you will have to use [[wikipedia:Regular expression|regex]] to instruct the built-in command on the file extensions to be considered (see [[#Commander|Commander]]'s built-in help for several regex examples). E.g., typing the following in the ''File name contains'' field of <span style="border-bottom:1px dotted #ccc;">Process▷ Batch▷ Macro...</span>, would restrict processing to <tt>.tif</tt>, <tt>.stk</tt> and <tt>.oib</tt> files (the default extensions specified in the <tt>validExtension()</tt> function of  {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_IJM.ijm|label=Process_Folder_IJM.ijm}}):
<source lang=java>(.*(\.(?i)(tif|stk|oib))$)</source>
}}
=== Example: Batch Randomization of Filenames ===
The default task of both the Python and IJM implementation of {{GitHub|org=tferr|repo=Scripts|path=Snippets/README.md#batch-processors|label=BAR}} ''Process Folder'' scripts is
filename randomization: 1) They copy images from one folder to another, 2) Rename their filenames using a random string and 3) Log changes to a CSV table (so that id of randomized filename can be traced back to the original file). This approach allows for blind analyses of datasets that are sensitive to user interpretation. Below are the descriptions of {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_PY.py|label=Process_Folder_PY.py}} and {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_IJM.ijm|label=Process_Folder_IJM.ijm}}.

===== Python =====
In Python we can use the [http://docs.python.org/library/uuid.html uuid module] to generate a random filename (rational [http://stackoverflow.com/a/10501355 here]). The result is an impressively succinct function:
<source lang="python">
def myRoutines(image):
    import uuid
    image.setTitle( str(uuid.uuid4()) )
</source>
In more detail: Pass the active image - an
[http://javadoc.imagej.net/ImageJ1/ij/ImagePlus.htm ImagePlus] object - to <tt>myRoutines()</tt>. Retrieve a random [[wikipedia:Universally unique identifier|UUID]] (e.g., <code>f7dfd6a9-f745-42c2-8874-0af67380c3f5</code>), convert it to a string, then use that string to rename the image using the [http://javadoc.imagej.net/ImageJ1/ij/ImagePlus.html#setTitle(java.lang.String) setTitle()] method in <tt>ij.ImagePlus</tt>.

But because [[#lib|BAR libs]] already contain such a function, we can just call the <tt>randomString()</tt> function in {{GitHub|org=tferr|repo=Scripts|path=lib/BARlib.py|label=BARlib.py}}, after loading the file:
<source lang="python">
def myRoutines(image):
    import sys, bar
    sys.path.append(bar.Utils.getLibDir())
    import BARlib as lib
    image.setTitle( lib.randomString() )
</source>

To log filename changes, we could use the same strategy used for the [[#IJ_Macro_Language|IJM implementation]]. The simplest way to generate a CSV list would be to use ImageJ's Log window:
<source lang="python">
def myRoutines(image):
    import uuid
    from ij import IJ

    # Remember original filename before changing it
    log_row = image.getTitle()
    # Rename image
    image.setTitle( str(uuid.uuid4()) )
    # Append modified filename to CSV row
    log_row += ", " + image.getTitle()
    # Print row
    IJ.log(log_row)
</source>
However,  we can use the [http://docs.python.org/library/csv.html csv module] to achieve a more robust  implementation:
<source lang="python">
import csv, os

# Create a CSV table documenting processed files
csvPath = out_dir + "_ProcessedFileList.csv"
csvExists = os.path.exists(csvPath)
csvFile = open(csvPath, 'a')
csvWriter = csv.writer(csvFile)

# Specify column headings
if not csvExists:
    headers = ['Original path','Processed path']
    csvWriter.writerow(headers)
</source>
As such, we only need to add the following, every time a file is processed:
<source lang="python">
csvWriter.writerow([old_filename, new_filename])
</source>
Visit the {{GitHub|org=tferr|repo=Scripts|label=BAR repository}} to check how the assembled script ({{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_PY.py?raw=true|label=Process_Folder_PY.py}}) {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_PY.py|label=looks like}}.

==== IJ Macro Language ====
In an ImageJ macro (IJM) we will need to define first a function that produces a random filename. The IJM language does not feature an equivalent to the UUID module used previously in the [[#Python|Python implementation]]. So, we are left with two approaches: 1) call [http://javadoc.imagej.net/Java8/java/util/UUID.html#randomUUID-- java.util. randomUUID] directly, or 2) write an ad-hoc function.

For the former, we take advantage of the IJM language built-in [http://imagej.nih.gov/ij/developer/macro/functions.html#call call()] function, that calls public static methods in any Java class that ImageJ is aware of:
<source lang="java">
function myRoutines() {
	randomString = call("java.util.UUID.randomUUID");
	rename(randomString);
}
</source>
or even shorter:
<source lang="java">
	rename(call("java.util.UUID.randomUUID"));
</source>
But discovering which methods can be called by the IJM language may not be trivial. Typically, it will require access to an [[IDE]] and some Java experience. So what about writing an ad-hoc function?

The approach used in {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_IJM.ijm|label=Process_Folder_IJM.ijm}} is the following: 1) Take a template string containing the characters A-Z and digits 0-9; 2) Pick a random position between the first and last character of the string template. Extract the character at that position; 3) Repeat the last step several times, assembling extracted characters into a concatenated string:
<source lang="java">
function randomString() {
	// We define the template and measure the number of positions
	template = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	nChars = lengthOf(template);
	// We define an empty string that will hold the result
	string = "";
	// We will want a final string to be 10-characters long
	for (i=0; i<10; i++) {
		// Define a random position between 0 and the penultime character in template
		idx = maxOf(0, round(random()*nChars-1));
		// Extract and concatenate characters
		string += substring(template, idx, idx+1);
	}
	// return result
	return string;
}
</source>
This would create e.g., <code>NHH6KG30C9</code>. However, a lengthier filename may be required. Larger filenames would be harder to read, so we can insert hyphens at fixed positions. We will improve the function by passing two arguments to it: the length of the desired filename and a boolean flag to instruct on the usage of hyphens:
<source lang="java">
function randomString(length, spacers) {
	template = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	nChars = lengthOf(template);
	string = "";
	for (i=0; i<length; i++) {
		idx = maxOf(0, round(random()*nChars-1));
		string += substring(template, idx, idx+1);
		if (spacers && i%5==0) string += "_";
	}
	return string;
}
</source>
As such, calling <code>randomString(50, true)</code> would produce e.g., <code>E_ZXTQO_8E9XM_45WG7_8S39</code>. As with the [[#Python|Python]] implementation, we could also use [[#lib|BAR lib]] (in this case {{GitHub|org=tferr|repo=Scripts|path=lib/BARlib.ijm|label=BARlib.ijm}}). First, we need to load the file [[#faq:ijm-lib|before running our macro]], using the code generated by <span style="border-bottom:1px dotted #ccc;">Bar▷ Snippets▷ New Snippet</span>:<span id="IJMlib"></span>
<source lang="java">
libPath = call('bar.Utils.getLibDir') + 'BARlib.ijm';
libContents = File.openAsString(libPath);
call('ij.macro.Interpreter.setAdditionalFunctions', libContents);

// Press 'Run' twice to confirm availability of new additions
confirmLoading();
</source>
Once ''lib/BARlib.ijm'' is in memory, the function can be called directly:
<source lang="java">rename( randomString(50, true) );</source>
Now that we are capable of generating a random filename, we just need to monitor filename changes. We could use the [http://imagej.nih.gov/ij/developer/macro/functions.html#print print()] function (that outputs to the Log window), or create a two-column table describing the changes. Here is how the final {{GitHub|org=tferr|repo=Scripts|path=Snippets/Process_Folder_IJM.ijm|label=Process_Folder_IJM.ijm}} looks like:
<source lang="java">
function myRoutines() {

	// Note that functions can contain other functions
	function randomString(length, spacers) {...}

	// Since we'll be logging filename changes to the Results table, we
	// need to keep track of the table's measurement counter. We'll assume
	// that the Results table was closed when myroutines() was first called
	availableRow = maxOf(0, nResults);
	// Log original filename before changing it
	setResult("Original filename", availableRow, getTitle());
	// Rename image and log changes
	rename(randomString(20, true));
	setResult("Randomized filename", availableRow, getTitle());
}
</source>

== FAQ ==
;What is the rationale behind BAR?
:The motivation behind bar is quite simple: To collect snippets of code that can be incorporated into any workflow. So rather than performing fully fledged procedures, BARs tend to produce single tasks. The advantages are two-fold: 1) Scripts are easier to understand and maintain and 2) they can be used to complement any other ImageJ add-on, let it be the simplest macro or the most sophisticated plugin.

;Will I find BAR useful?
:{{GitHub|org=tferr|repo=Scripts|path=README.md#citations|label=Probably}}. But it is likely that you will need to delve a bit into the [[#Scripting_BARs|BAR philosophy]].

;Can I contribute to BAR?
: Yes, please do! If you have some suggestions on how to improve it, do {{GitHub|org=tferr|repo=Scripts|path=README.md#help|label=let us know}}.

;Nothing happens when I run a BAR. What's going on?
:In a case of premature termination BARs tend to exit rather silently. The best way to have insights on an unexpected error is to run it directly from the [[Script Editor]]: Open the script by holding {{key press|Shift}} while selecting it from the <span style="border-bottom:1px dotted #ccc;">BAR▷</span> menu, press ''Run''  and have a look at the editors' s console, where all sort of useful messages will be printed to. Do {{GitHub|org=tferr|repo=Scripts|path=README.md#help|label=let us know}} if you have found a bug.

;<span id="faq:ImageJ1"></span>Does BAR work outside Fiji/ImageJ2?
:Yes, but with limitations. ImageJ1 (see [[ImageJ#Flavors|ImageJ Flavors]] if you have doubts about existing ImageJ distributions) will only register scripts saved in the ''plugins/'' folder or on one of its immediate subfolders. For this reason, some of the {{bc|BAR|}} submenus will appear as empty, and it may not be possible to navigate the ''BAR/'' directory using menu commands ([[#Commander|Commander]] could still be used, nevertheless). Another important aspect is that, without access to the [[Update_Fiji|built-in updater]], you will have to manually update BAR (by monitoring its {{GitHub|org=tferr|repo=Scripts/releases|label=rpository}}), and to manually install (and update) the dependencies (i.e., third-party plugins and third-party libraries) used by BAR).

;How do I uninstall BAR?
:Run the [[Fiji Updater|Updater]] ({{bc|Help|Update...}}). Choose ''Advance Mode'' then ''Manage update sites''. Deactivate the ''BAR'' checkbox in the alphabetically-sorted list of update sites. Press ''OK'', then ''Apply changes''. All BAR files will be deleted. Note that you can install and uninstall BAR as you see fit. See [[How to follow a 3rd party update site]] for more details.

;<span id="faq:ijm-lib"></span>I get an error when I try to load BAR lib (IJM). Why?
:Macro functions from a IJ macro [[#lib|lib]] may only be available once a new instance of the macro interpreter is initiated (this is not the case for other scripting languages). This means you have to call <code>ij.macro.Interpreter.setAdditionalFunctions</code> <u>before</u> running your macro. You can test this by running the default macro generated by <span style="border-bottom:1px dotted #ccc;">BAR▷ Snippets▷New Snippet...</span>:
<source lang=java>
// Load BARlib.ijm
libPath = call('bar.Utils.getLibDir') + 'BARlib.ijm';
libContents = File.openAsString(libPath);
call('ij.macro.Interpreter.setAdditionalFunctions', libContents);
</source>
:The first time you run <code>confirmLoading();</code> ImageJ will complain about <code>confirmLoading</code> being an undefined identifier, but it will successfully recognize the call the second time you run the code above.

== Citation ==
BAR scripts can be cited using the DOI associated with the repository:
:* Tiago Ferreira et al., (2016)  [http://dx.doi.org/10.5281/zenodo.28838 <img src="https://zenodo.org/badge/doi/10.5281/zenodo.28838.svg" alt="10.5281/zenodo.28838">]

== License ==
These scripts are free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the [http://www.gnu.org/licenses/gpl.txt Free Software Foundation]. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

[[Category:Analysis]]
[[Category:Filtering]]
[[Category:Image annotation]]
[[Category:Plugins]]
[[Category:Scripting]]
[[Category:Segmentation]]
