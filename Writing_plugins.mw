{{Notice | This guide provides a technical overview of [[plugins]], including how to '''create new plugins'''.<br>
* If you are interested in developing an '''existing''' plugin instead, see [[How to contribute to an existing plugin or library|Contributing to a plugin]].<br>
* If you have completed a plugin that you would like to '''share with the community''', see [[Distribution|Distributing your plugins]].
}}


{{DevelopMenu | tutorials}}
{{TOC}}

== Requirements ==


As ImageJ is built using the [[Project_management|SciJava principles of project management]], this guide assumes a basic familiarity with these topics and tools, especially:

{|
| style="text-align: center; padding: 0.3em" | [[File:Git-icon.png | 64px | link=Git]]
| style="text-align: center; padding: 0.3em" | [[File:Maven-icon.png | 64px | link=Maven]]
|-
| style="text-align: center; padding: 0.3em" | [[Git]]
| style="text-align: center; padding: 0.3em" | [[Maven]]
|}

Additionally, at a minimum, you should clone the {{GitHub|org=imagej|repo=imagej-tutorials|label=imagej-tutorials repository}}. This will give you a local copy of the tutorials discussed in this guide, as well as templates for use in your own development.

For the complete "developer experience", you can go through the [https://help.github.com/categories/bootcamp/ GitHub Bootcamp]. At the least, once you've [https://help.github.com/articles/create-a-repo/ created your own repository] and cloned a local copy, you will have a home ready for when your [[#Starting_your_own_plugin|very own plugin]] arrives!

== What is a "plugin"? ==

Conceptually, a '''plugin''' is a new piece of functionality added to ImageJ. Nearly all aspects of ImageJ are ''pluggable'', meaning plugins can be provided ''ad hoc'' to perform specified functions. The ImageJ core needs only know what general operations are available; then when the program is running, the options for how to complete a requested operation will be determined by which plugins are available at that time.

Technically, ImageJ is built on the [[SciJava Common]] plugin framework. Within this framework, a plugin is a Java class [https://docs.oracle.com/javase/tutorial/java/annotations/index.html annotated] with the {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/plugin/Plugin.java|label=@Plugin}} annotation. Classes annotated in this way are then automatically discovered and indexed at [[wikipedia:Run_time_(program_lifecycle_phase)|''runtime'']], when the application is launched by a user (as opposed to [[wikipedia:Compile_time|''compile-time'']]).

=== Plugin types ===

There is no limit to how many plugins can be discovered at runtime. To allow efficient retrieval of plugins, each class is annotated with a specific '''type''' - typically a [https://docs.oracle.com/javase/tutorial/java/concepts/interface.html Java interface] - by which the plugin will be indexed. This indexing follows Java type hierarchies.

For example, given the following plugins:

<source lang=java>
@Plugin(type=Service.class)
public class MyService implements Service { }
</source>


<source lang=java>
@Plugin(type=SpecialService.class)
public class SpecialService implements Service { }
</source>

{{ExpandingBox
| Which of these plugins would we expect back if asking the [[Writing_plugins#The_Context|Context]] for plugins of type <code>Service</code> plugin?
| > It would give back both the <code>MyService</code> and <code>SpecialService</code> plugins, since <code>SpecialService</code> is a subclass of <code>Service</code>.
}}

{{ExpandingBox
| What if we asked for plugins of type <code>SpecialService</code>?
| > It would just return the <code>SpecialService</code> plugin, since <code>MyService</code> is '''not''' a <code>SpecialService</code>.
}}

=== Plugin priority ===

When plugins are retrieved from a [[Writing_plugins#The_Context|Context]] it's possible to get more than one match. In these cases, the plugin classes are returned in order of the '''priority''' of the class's [https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/plugin/Plugin.java#L108-L129 @Plugin annotation]. Priorities are simply double values; as a starting point, priority constants can be used from the {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/Priority.java|label=Priority}} class.

For example, given the following plugins:

<source lang=java>
@Plugin(priority=Priority.HIGH_PRIORITY)
public class MyService implements Service { }
</source>


<source lang=java>
@Plugin(priority=224)
public class SpecialService implements Service { }
</source>

{{ExpandingBox
| Which plugin would be returned first if we asked the Context for a <code>Service</code> plugin?
| > The <code>SpecialService</code> plugin would come back first. If we look at the <code>Priority</code> class we see that HIGH_PRIORITY simply [https://github.com/scijava/scijava-common/blob/scijava-common-2.47.0/src/main/java/org/scijava/Priority.java#L54-L55 resolves to 100].
}}

We can also use ''relative priorities'' when referring to particular priority constants. This is a nice way to give the best chance that sorting will remain the same even if these constants change in the future:

<source lang=java>
@Plugin(priority=Priority.HIGH_PRIORITY+124)
public class SpecialService implements Service { }
</source>

== What makes up the SciJava plugin framework? ==

=== The Context ===

References to all the <code>@Plugin</code>-annotated classes that are discovered are contained in a single, master {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/Context.java|label=Context}}. Each application is responsible for creating its own <code>Context</code> to manage plugins and contextual state.

In ImageJ, a <code>Context</code> is automatically created when {{GitHub|org=imagej|repo=imagej|tag=imagej-2.0.0-rc-39|source=net/imagej/ImageJ.java|label=the application starts up}}, so plugin developers do not need to create their own. In fact, creating your own <code>Context</code> typically causes problems, as it will be a different container than ImageJ is using. Instead, plugin instances within a common <code>Context</code> are provided automatically by the framework—you just have to ask.

Typically, ImageJ plugin developers will be writing [[#Services|Service]] and/or [[#Commands|Command]] plugins. If you need to use another plugin - for example the {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/log/LogService.java|label=LogService}} - you '''should not''' manually create it as this effectively disconnects you from your <code>Context</code> (Your [[#Services|Service]] and/or [[#Commands|Command]] plugins are created by the application container and managed by the plugin framework automatically). Instead, you should ask your <code>Context</code> for an instance by adding a field of the desired type and annotating it with the {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/plugin/Parameter.java|label=@Parameter annotation}}. For example:

<source lang=java>
@Plugin
public class MyPlugin {
 
  // This @Parameter notation is 'asking' the Context
  // for an instance of LogService.
  @Parameter
  private LogService logService;
 
  public void log(String message) {
    // Just use the LogService!
    // There is no need to construct it, since the Context
    // has already provided an appropriate instance.
    logService.info(message);
  }
}
</source>

This will allow the <code>Context</code> to provide you with the appropriate instance of your requested service.

In some cases, manual plugin construction is unavoidable. Understand that if the <code>MyPlugin</code> class above is manually constructed—i.e. via <code>new MyPlugin()</code>—the <code>LogService</code> parameter will be <code>null</code>. Automatic population only occurs if the plugin instance itself is retrieved via the framework. When you must manually construct a plugin instance, you can still re-connect it to an existing <code>Context</code> via its ''injection'' mechanism:

<source lang=java>
public class MyService {

  // This service will manually create plugin instances
  // So, we need a reference to our containing Context
  // Then we can use it to inject our plugins.
  @Parameter
  private Context context;

  public void doStuff() {
    // Manually create a plugin instance
    // It is not connected to a Context yet
    MyPlugin plugin = new MyPlugin();

    // Inject the plugin instance with our Context,
    // so the logService field of the plugin will be
    // populated.
    context.inject(plugin);

    // Now that our plugin is injected, we can use
    // it with the knowledge that its parameters
    // have been populated
    plugin.log("Success!");
  }
}
</source>

=== Services ===

Services provide two important functions to the SciJava framework: utility methods and persistent state. If you want to add reusable Java methods that can be used throughout the SciJava framework, then you should create a <code>Service</code> to provide this functionality. If you need to track Context-wide variables or configuration, a <code>Service</code> should be used to encapsulate that state.

Conceptually, a <code>Service</code> satisfies the role of [[wikipedia:Utility class|static utility classes]] on a per-Context basis. In this way, only one [http://math.hws.edu/javanotes/c5/s1.html instance] of each <code>Service</code> class can be associated with a given <code>Context</code> instance; an association that occurs automatically during <code>Context</code> creation. Furthermore, when a <code>Context</code> is asked for an implementation of a given <code>Service</code>, only the highest priority instance will be returned.

Services often build on or reuse functionality defined in each other. For example, the {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/plugin/PluginService.java|label=PluginService}} sees ubiquitous use in retrieving and working with plugin instances. For such reuse, {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/plugin/Parameter.java|label=@Parameter annotation}} can be used to declare inter-service requirements. During <code>Context</code> startup, these relationships will be resolved automatically.

=== Commands ===

Whereas [[#Services|Services]] provide internal functionality, <code>Commands</code> are plugins designed to be executed as one-offs, typically interacting with users to achieve some desired outcome. When opening the ImageJ GUI, Commands are what populate your menu structure: exposing functionality and algorithms in a way that can be consumed by non-developers.

When writing <code>Commands</code> you will often declare {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/plugin/Parameter.java|label=@Parameters}} on fields that '''can not''' be resolved automatically by the <code>Context</code>—for example, numeric values or file paths. Instead of being instantiated at <code>Context</code> startup as a <code>Service</code> would be, <code>Commands</code> are created and executed on demand.

When a <code>Command</code> is executed, it goes through a series of pre-processing steps to populate its <code>@Parameters</code> using its associated [[#The_Context|Context]]. If any parameters are left unresolved and a UI is available, the framework will automatically build and display an appropriate dialog to get user input. In this way, input harvesting is decoupled from functional operation—allowing developers to focus on what's really important without repetition of code. This also means that Commands can typically run [[Headless|headlessly]] without any extra development effort.

A common pattern in <code>Command</code> development is to wrap <code>Service</code> functionality. For example, opening an image from a path is a fundamental operation in ImageJ. To this end, developers can directly use the {{GitHub|org=scifio|repo=scifio|tag=scifio-0.25.0|source=io/scif/services/DatasetIOService.java|label=DatasetIOService}}. Users then get this same functionality from the menus via the {{GitHub|org=imagej|repo=imagej-plugins-commands|tag=imagej-plugins-commands-0.6.0|source=net/imagej/plugins/commands/io/OpenDataset.java|label=OpenDataset command}}—which itself simply calls into the <code>DatasetIOService</code>.

=== Other plugins ===

Because virtually everything is a plugin in ImageJ, there are too many to explicitly enumerate, let alone cover in a tutorial. To get ideas for functionality that can be added, a good starting point is to look for services in the [[Javadoc|javadoc]], or the [http://search.imagej.net/ ImageJ search portal]. Many service types have supplemental plugins for easy functional extension. In particular, the {{GitHub|org=imagej|repo=imagej-common|label=imagej-common}} and {{GitHub|org=scijava|repo=scijava-common|label=scijava-common}} repositories will contain plugin definitions for many essential operations.

A brief list of some of the more useful plugin types to extend:

* [[Ops]] provide a reusable set of image processing algorithms.
* [[Adding_new_file_formats|Image formats]] allow new types of images to be opened in ImageJ.
* {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/convert/Converter.java|label=Converters}} allow the framework to interchange types, outside of normal Java class hierarchy restrictions.
* {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/module/process/PreprocessorPlugin.java|label=Input Preprocessors}} give you control over the population of <code>@Parameters</code>.
* {{GitHub|org=scijava|repo=scijava-common|tag=scijava-common-2.47.0|source=org/scijava/display/Display.java|label=Displays}} control how UI elements are presented to users.

If you know the function you want to modify but can't determine its location in the code, please [[Help|ask other developers.]] You're part of the community now!

== Example projects ==

Remember the {{GitHub|org=imagej|repo=imagej-tutorials|label=imagej-tutorials repository}} we [[#Requirements|said you should clone]]? Now's the time to put it to use!

Because the ImageJ API is designed to be maximally flexible and extensible, if you're just getting started with development it can be overwhelming to figure out exactly which part of the code base you should be working on. The <code>imagej-tutorials</code> repository contains a selection of minimal projects illustrating how your own project(s) could be structured to perform common tasks. Most of these projects also have extensive documentation via comments in the code, to highlight particular functions and use cases.

You do not need to understand every project in this repository, nor must you go through them in a particular order! Instead, you should read through the following topics and focus on the projects that look particularly interesting and relevant to your goals. Your target for learning should be to understand the code in these selected projects, and how changes to that code will be reflected in the experiences of users and other developers.

Because these tutorials use [[Git]] for source control, you have complete freedom to modify and play with the code. Worst-case scenario, you always have a big reset button via the command:

<source lang=bash>
git reset --hard origin/master
</source>

There are always other options for saving or restoring your work—[https://git-scm.com/book/en/v1/Git-Tools-Stashing stashing] or [https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell branching], for example—but their use will depend on your personal comfort and knowledge of Git.

=== Tips ===

* Most of these examples have a [https://docs.oracle.com/javase/tutorial/getStarted/application/index.html Main method] to see the code in action.
* All of these projects are [[Maven|Mavenized]].
* You can look at the [https://maven.apache.org/guides/introduction/introduction-to-the-pom.html pom.xml] to figure out [[Source|which libraries]] that particular project is using.
* You can [http://maven.apache.org/archives/maven-1.x/start/quick-start.html compile and build] from the command line by running <code>mvn</code> from any project's top-level directory (any directory containing a <code>pom.xml</code>).
* Building a project results in a <code>jar</code> output in the <code>$PROJECT/target/</code> directory.
* For a more "real-world" experience, you can drop the <code>jar</code> you built into the <code>ImageJ.app/jars/</code> directory of an [[Downloads|ImageJ installation]] to try out any of the example plugins.
* If you're not sure how to find your plugin within ImageJ, use the [[Command Finder]]!
* You can also import each project into [[Eclipse]]/[[NetBeans]]/[[IntelliJ IDEA]] as a [https://books.sonatype.com/m2eclipse-book/reference/creating-sect-importing-projects.html maven project].

=== First steps ===

The [https://github.com/imagej/imagej-tutorials/blob/master/intro-to-imagej-api/src/main/java/IntroToImageJAPI.java IntroToImageJ API] class documents many common functions and structures in ImageJ, and is a great starting point.

=== Basic plugins ===

These projects provide minimal examples with thorough online documentation.
* [https://github.com/imagej/imagej-tutorials/tree/dev-manual/minimal-ij2-plugin minimal-ij2-plugin] - A minimal ImageJ plugin template
* Look at some [https://github.com/imagej/imagej-tutorials/tree/master/simple-commands/src/main/java simple commands] and see how they interact with users
* [https://github.com/imagej/imagej-tutorials/tree/master/working-with-modules/src/main/java Getting started with modules]—the foundation of many user-facing plugin types, including [[#Commands|commands]]

=== Targeted tasks ===

These projects are examples of specific ''use cases'' within the ImageJ API.

* [https://github.com/imagej/imagej-tutorials/tree/master/execute-commands/src/main/java Execute commands programmatically]
* [https://github.com/imagej/imagej-tutorials/tree/master/load-and-display-dataset/src/main/java Open a dataset]
* [https://github.com/imagej/imagej-tutorials/tree/master/add-rois/src/main/java Combine ROIs]
* [https://github.com/imagej/imagej-tutorials/tree/master/listen-to-events/src/main/java React to framework events]—such as creating a dataset

=== Working with Ops ===

* [https://github.com/imagej/imagej-tutorials/tree/master/using-ops/src/main/java Using Ops]
* [https://github.com/imagej/imagej-tutorials/tree/dev-manual/using-ops-dog Using Ops DoG filter]
* [https://github.com/imagej/imagej-tutorials/tree/master/add-two-datasets/src/main/java Add datasets]
* [https://github.com/imagej/imagej-tutorials/tree/master/create-a-new-op Create a new Op type]

=== Working with user input ===

* [https://github.com/imagej/imagej-tutorials/tree/master/widget-demo/src/main/java Look at all the widgets!]
* [https://github.com/imagej/imagej-tutorials/tree/master/commands-with-preview/src/main/java Previewable commands]

=== Plugin development ===

* [https://github.com/imagej/imagej-tutorials/tree/master/create-a-new-plugin-type/src/main/java Create a new plugin type]
* [https://github.com/imagej/imagej-tutorials/tree/master/custom-preprocessor-plugin/src/main/java Create a new preprocessor]

== Starting your own plugin ==

=== General guidelines ===

ImageJ adheres to [[Coding_style#Interface-driven_design|interface-driven design]]. From a practical point of view, this means:

If you are '''creating''' a new plugin type...
* Use interfaces for base plugin type
* Create an abstract class implementing this interface that handles all the boilerplate.
* Your abstract class can likely extend a general abstract class provided in  {{GitHub|org=imagej|repo=imagej-common|label=imagej-common}} or {{GitHub|org=scijava|repo=scijava-common|label=scijava-common}}

If you are '''implementing''' an existing plugin type...
*Just extend the appropriate abstract class! Let your compiler tell you which methods are missing.

=== Adopt an existing project ===

You already [[#Requierments|created your own GitHub repository]], right??

When you're just getting started with tools like [[Git]] and [[Maven]], it's not easy to comprehend the nuances of how new projects should be set up and configured. It's much easier to copy a working project to use as a starting point and go from there.

The [[#Example projects|example projects]] are designed precisely to serve as such starting points for new projects. Once you have a solid idea of what kind of plugin you want to write, pick the project that discusses your area of choice and simply copy it to your own GitHub repo. From there, you can make changes as needed.

At this point, if you haven't already, we '''STRONGLY RECOMMEND''' importing your project into an [[IDE]] like [[Eclipse]]. This will make [[Developing_Fiji_in_Eclipse|development]] and [http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-menu-refactor.htm refactoring] much easier. Modern IDEs also have excellent [[Git]] and [[Maven]] integration, which will allow you to take advantage of the fact that the example projects are already set up as Mavenized Git repositories.

In addition to modifying and developing the source code itself, there are several things you should do to properly identify and configure your project:

==== Update your POM ====

* Update your [https://maven.apache.org/pom.html#Inheritance parent pom]. This will dictate what [https://maven.apache.org/pom.html#Dependency_Management dependency management] is available to you. If you're writing a core ImageJ plugin, then <code>pom-imagej</code> is appropriate. A [[Fiji]] plugin should use [https://github.com/fiji/pom-fiji <code>pom-fiji</code>], however.
* Update pom version to latest: which depends on if your parent is [https://github.com/imagej/pom-imagej/releases pom-imagej] or [https://github.com/fiji/pom-fiji/releases pom-fiji]
* Update your [https://maven.apache.org/pom.html#Maven_Coordinates groupId]. ImageJ projects use a <code>net.imagej</code> groupId, while Fiji projects use <code>sc.fiji</code>—or you may use your own if you do not plan to distribute your plugin with the core ImageJ or Fiji projects.
* Update your [https://maven.apache.org/pom.html#Maven_Coordinates artifactId] to something appropriate based on the intended use of your project.
* Update your <code><name></code> and <code><description></code> to something appropriate for your new artifactId.

==== Code changes ====

* If you updated your pom's groupId, you should similarly update the [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html package] structure (found in [https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html <code>src/main/java</code>]) to match.

==== Optional changes ====

* If you want to use additional [[Source_code|ImageJ or Fiji projects]] as libraries, you will need to add them as dependencies in the [https://maven.apache.org/pom.html#Dependencies dependency block] of your <code>pom.xml</code>. Note that you will not need to specify a <code><version></code>, as these are managed by your parent pom.
* Non-core ImageJ developers should add a <code><developer></code> block to their pom, to identify yourself (see [https://github.com/imagej/pom-imagej/blob/pom-imagej-13.1.0/pom.xml#L34-L85 this example] for formatting).
* Alternatively, you could submit a pull request to pom-imagej adding yourself as a [https://github.com/imagej/pom-imagej/blob/pom-imagej-13.1.0/pom.xml#L86-L166 contributor]!
* If your copied <code>pom.xml</code> has a [https://github.com/imagej/imagej-tutorials/blob/249c699dbdb9308f8a5539f0f39cf84d2612b273/simple-commands/pom.xml#L22-L24 main method specification] you will likely need to remove or update it as appropriate.
* If you want to add non-Java files to your plugin, such as sample images or [[Scripting|demo scripts]], refer to the [https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html standard maven layout].

== Next Steps ==

There are further guides available dedicated to developing particular types of plugins:

* [[Adding new ops]]
* [[Adding new file formats]]

Once you have completed plugins and want to get them out to users, you can familiarize yourself with the articles on:

* [[Distribution|Plugin distribution]]
* [[Development Lifecycle|The development lifecycle]]
* [[Fiji_contribution_requirements|Core contribution requirements]]

As always, if you ever need assistance, [[Help|just ask]]!

[[Category:Tutorials]]
[[Category:ImageJ2]]
[[Category:Development]]
