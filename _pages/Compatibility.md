---
autogenerated: true
title: Compatibility
layout: page
categories: development
description: test description
---

{% include component-stats content='net.imagej:imagej-legacy' %}Backward compatibility is one of ImageJ's most important goals. It must remain possible to use existing plugins and macros with new versions of [ImageJ](/about).

ImageJ Legacy
-------------

The [ImageJ2](/software/imagej2) project is a complete redesign of ImageJ, with no dependency on [ImageJ 1.x](/software/imagej1). However, to facilitate backwards compatibility, there is an **ImageJ Legacy** component (source {% include github org='imagej' repo='imagej-legacy' %}) which provides extensions for ImageJ2 and ImageJ1 to operate in harmony.

The ImageJ legacy layer provides the following extensions:

-   It makes ImageJ 1.x **usable [headless](Headless)** from the command line.
-   It wraps the **ImageJ 1.x UI as a [SciJava](SciJava) user interface**.
-   It **translates between ImageJ1 and ImageJ2 data structures** on demand.

ImageJ2 currently uses the ImageJ 1.x user interface by default, since many users need to retain access to ImageJ1 plugins.

### The ImageJ legacy UI

The legacy layer converts ImageJ1 into a SciJava-compatible user interface by implementing the {% include javadoc project='SciJava' package='org/scijava/ui' class='UserInterface' %} interface via the {% include javadoc package='net/imagej/legacy/ui' class='LegacyUI' %} class.

However, things are complicated by the fact that ImageJ1 was not designed with such requirements in mind. The legacy layer uses a bytecode manipulation library called [Javassist](/develop/javassist) to rewrite portions of ImageJ1 at runtime, in order to facilitate integration and extension. See the {% include github org='imagej' repo='ij1-patcher' label='ij1-patcher' %} project for details.

### Translation of data structures

Each {% include javadoc package='net/imagej/display' class='ImageDisplay' %} has a linked {% include javadoc project='ImageJ1' package='ij' class='ImagePlus' %}, kept in sync by the {% include javadoc package='net/imagej/legacy' class='LegacyImageMap' %}. Whenever the need arises, the legacy layer syncs the linked data objects. In order to maintain reasonable performance, every opportunity is taken to avoid data translation by making data changes in place, and only on demand (lazily, with caching). The legacy layer reuses data by reference when feasible—in particular, when image planes are stored in primitive arrays—but in some cases the data must be copied (e.g., for ROIs).

Currently, automatic synchronization is disabled as it has negative performance implications. The planned solution to the performance problems is to {% include github org='imagej' repo='imagej-legacy' issue='86' label='implement a wrapping layer' %}, instead of relying on up-front pixel-wise translation.

In the mean time, full synchronization can be forced by setting a `imagej.legacy.sync` [system property](https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html). This can be done in a running ImageJ instance, for example by running the following as a [BeanShell script](/scripting/beanshell):

    System.setProperty("imagej.legacy.sync", "true");

Updating ImageJ commands to the new paradigm
--------------------------------------------

The eventual goal is to migrate all core ImageJ1 plugins to the ImageJ2 paradigm. Many ImageJ1 plugins have been already been updated in this fashion; see the {% include github org='imagej' repo='imagej-ops' label='imagej-ops' %} and {% include github org='imagej' repo='imagej-plugins-commands' label='imagej-plugins-commands' %} repositories in particular.

See also
--------

-   The [ImageJDev talk](http://conference.imagej.net/2010/curtis-rueden/2010-10-27-ImageJDev.pdf) from the ImageJ 2010 Conference, for a historical perspective on how this approach to compatibility evolved over time.
